# 클라이언트 파트 진행 상황
async/await, tcpClient 활용하여 서버와 통신 <br/>
서버 <-> 클라이언트 간의 패킷 전달 시 패킷 분할 현상 해결 <br/>
SignUp 결과 수신 및 패킷처리 까지 완료 (이후 팝업 메시지를 띄워 결과 확인.)<br/>
SignIn 결과 수신 및 정보 요청 후 수신 완료 (SignIn -> GetCharList -> GetCharInfo)<br/>
GetCharList로 CharCode 리스트를 수신한 뒤, 해당 정보로 다시 GetCharInfo 요청 (캐릭터가 아직 없는 계정은 바로 씬 전환.)<br/>
GetCharInfo로 수신한 정보를 저장한 뒤, 모든 CharList의 CharInfo를 수신 완료했으면 캐릭터 선택창으로 씬 전환. <br/>
CreateChar 과정 구현. (ReserveCharName -> CreateChar) ReserveCharName을 호출한 뒤 생성가능한 경우 생성여부 재확인 창을 띄운다. 재확인창에서 생성을 선택한 경우 최종적으로 캐릭터가 생성된다. <br/>
ReserveCharName으로 생성가능한 닉네임에 예약을 건 후 생성여부를 재확인한다. 생성창에서 닉네임을 입력하고 버튼을 누르면 호출한다. <br/>
CancelCharNameReserve로 예약한 닉네임의 예약을 취소할 수 있다. 재확인창에서 생성을 거부하는 경우 호출한다. <br/>

## 패킷 분할
[MTU](https://github.com/SuhYC/Lesson/blob/main/Network/MTU.md)관련 내용과 연계되는 것으로 추정 (혹은 TCP 로직 처리 중에 분할되었을수도 있고..) <br/>
도착한 패킷만으로 메시지를 식별할 수 없는 경우 잔여버퍼를 따로 구성하여 저장해두도록 했다. <br/>
이후 도착한 패킷과 잔여버퍼의 메시지를 합쳐 식별할 수 있는 크기가 되면 해당 부분을 잘라 처리하고 남은 부분은 다시 잔여버퍼에 저장한다. <br/>
식별할 수 있는 크기가 되는지 확인하기 위해 메시지 앞에 [```size```]와 같이 작성한다. (페이로드 부분의 크기를 ```size```부분에 넣는방식) <br/>

-20250121- 슬슬 데이터 크기가 커지면서 기존에 처리하지 않았던 부분의 문제 발생.<br/>
한번의 2개 이상의 메시지가 1회의 IO로 수신된 경우 각 메시지를 처리한 후 잔여메시지를 저장해야하는데 <br/>
1개의 메시지만 처리하고 잔여메시지를 저장하고 함수를 종료하는 문제가 있었음. <br/>
처리 완료.

## 비동기 락
C#의 일반적인 락은 비동기 함수와 사용하기에 문제가 많다. <br/>
async 함수는 await 구문을 만나면 해당 부분의 동작이 완료되기 전까지 보류상태로 전환한 뒤 빠져나와 다른 함수를 실행해야하기 때문에 사용할 수 없다. <br/>
잔여메시지 관련으로 lock을 걸고 싶은데 수신과 수신처리에 있어서 async메소드를 사용하고 싶기 때문에 다른 방법을 사용한다. <br/>
SemaphoreSlim에서는 비동기를 위한 락을 제공한다. <br/>
다만 lock처럼 구문을 벗어날 때 자동으로 해제해주지는 않으므로 IDisposable인터페이스를 상속하여 자동으로 해제할 수 있도록 한다.
